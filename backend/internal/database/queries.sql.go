// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
)

const alterAccount = `-- name: AlterAccount :exec
UPDATE accounts
SET
    email = ?,
    address = ?,
    user_phone_number = ?
WHERE
    username = ?
`

type AlterAccountParams struct {
	Email           string
	Address         string
	UserPhoneNumber int64
	Username        string
}

func (q *Queries) AlterAccount(ctx context.Context, arg AlterAccountParams) error {
	_, err := q.db.ExecContext(ctx, alterAccount,
		arg.Email,
		arg.Address,
		arg.UserPhoneNumber,
		arg.Username,
	)
	return err
}

const alterFood = `-- name: AlterFood :exec
UPDATE food
SET
    price = ?,
    info = ?,
    ingredients = ?,
    time_needed = ?,
    picture = ?,
    description = ?
WHERE
    food_name = ?
`

type AlterFoodParams struct {
	Price       float64
	Info        sql.NullString
	Ingredients string
	TimeNeeded  int32
	Picture     sql.NullString
	Description string
	FoodName    string
}

func (q *Queries) AlterFood(ctx context.Context, arg AlterFoodParams) error {
	_, err := q.db.ExecContext(ctx, alterFood,
		arg.Price,
		arg.Info,
		arg.Ingredients,
		arg.TimeNeeded,
		arg.Picture,
		arg.Description,
		arg.FoodName,
	)
	return err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO accounts (username, password, email, address, user_phone_number)
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateAccountParams struct {
	Username        string
	Password        string
	Email           string
	Address         string
	UserPhoneNumber int64
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Address,
		arg.UserPhoneNumber,
	)
	return err
}

const createFood = `-- name: CreateFood :exec
INSERT INTO food (food_name, price, info, ingredients, time_needed, picture, description, food_type, long_range)
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateFoodParams struct {
	FoodName    string
	Price       float64
	Info        sql.NullString
	Ingredients string
	TimeNeeded  int32
	Picture     sql.NullString
	Description string
	FoodType    string
	LongRange   bool
}

func (q *Queries) CreateFood(ctx context.Context, arg CreateFoodParams) error {
	_, err := q.db.ExecContext(ctx, createFood,
		arg.FoodName,
		arg.Price,
		arg.Info,
		arg.Ingredients,
		arg.TimeNeeded,
		arg.Picture,
		arg.Description,
		arg.FoodType,
		arg.LongRange,
	)
	return err
}

const createOrder = `-- name: CreateOrder :exec
INSERT INTO orders (user_id, order_info, is_ranged, delivery_address)
VALUES (
    ?,
    ?,
    ?,
    ?
)
`

type CreateOrderParams struct {
	UserID          int32
	OrderInfo       string
	IsRanged        bool
	DeliveryAddress sql.NullString
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.ExecContext(ctx, createOrder,
		arg.UserID,
		arg.OrderInfo,
		arg.IsRanged,
		arg.DeliveryAddress,
	)
	return err
}

const createOrderedItem = `-- name: CreateOrderedItem :exec
INSERT INTO items (order_id, food_id, quantity)
VALUES (
    ?,
    ?,
    ?
)
`

type CreateOrderedItemParams struct {
	OrderID  int32
	FoodID   int32
	Quantity int32
}

func (q *Queries) CreateOrderedItem(ctx context.Context, arg CreateOrderedItemParams) error {
	_, err := q.db.ExecContext(ctx, createOrderedItem, arg.OrderID, arg.FoodID, arg.Quantity)
	return err
}

const deleteFood = `-- name: DeleteFood :exec
DELETE FROM food
WHERE food_name = ?
`

func (q *Queries) DeleteFood(ctx context.Context, foodName string) error {
	_, err := q.db.ExecContext(ctx, deleteFood, foodName)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
UPDATE orders
SET
    deleted = true
WHERE
    order_id = ?
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrder, orderID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE food_name = ?
`

func (q *Queries) DeleteTag(ctx context.Context, foodName string) error {
	_, err := q.db.ExecContext(ctx, deleteTag, foodName)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, username, password, email, address, balance, is_admin, user_tag, user_phone_number FROM accounts WHERE username = ?
`

func (q *Queries) GetAccount(ctx context.Context, username string) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccount, username)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Address,
		&i.Balance,
		&i.IsAdmin,
		&i.UserTag,
		&i.UserPhoneNumber,
	)
	return i, err
}

const getAdminAccount = `-- name: GetAdminAccount :one
SELECT id, username, password, email, address, balance, is_admin, user_tag, user_phone_number FROM accounts WHERE is_admin = true
`

func (q *Queries) GetAdminAccount(ctx context.Context) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAdminAccount)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Address,
		&i.Balance,
		&i.IsAdmin,
		&i.UserTag,
		&i.UserPhoneNumber,
	)
	return i, err
}

const getAllAccounts = `-- name: GetAllAccounts :many
SELECT id, username, password, email, address, balance, is_admin, user_tag, user_phone_number FROM accounts WHERE is_admin = false
`

func (q *Queries) GetAllAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, getAllAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Email,
			&i.Address,
			&i.Balance,
			&i.IsAdmin,
			&i.UserTag,
			&i.UserPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDeletedOrdersByUser = `-- name: GetAllDeletedOrdersByUser :many
SELECT order_id, user_id, order_info, feedback, order_time, estimated_time, is_done, is_ranged, delivery_address, deleted, is_paid FROM orders WHERE user_id = ? AND deleted = true
`

func (q *Queries) GetAllDeletedOrdersByUser(ctx context.Context, userID int32) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getAllDeletedOrdersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.OrderInfo,
			&i.Feedback,
			&i.OrderTime,
			&i.EstimatedTime,
			&i.IsDone,
			&i.IsRanged,
			&i.DeliveryAddress,
			&i.Deleted,
			&i.IsPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFood = `-- name: GetAllFood :many
SELECT food_id, food_name, price, food_type, picture, long_range, description, info, ingredients, time_needed FROM food
`

func (q *Queries) GetAllFood(ctx context.Context) ([]Food, error) {
	rows, err := q.db.QueryContext(ctx, getAllFood)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Food
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.FoodID,
			&i.FoodName,
			&i.Price,
			&i.FoodType,
			&i.Picture,
			&i.LongRange,
			&i.Description,
			&i.Info,
			&i.Ingredients,
			&i.TimeNeeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFoodLongRange = `-- name: GetAllFoodLongRange :many
SELECT food_id, food_name, price, food_type, picture, long_range, description, info, ingredients, time_needed FROM food WHERE long_range = true
`

func (q *Queries) GetAllFoodLongRange(ctx context.Context) ([]Food, error) {
	rows, err := q.db.QueryContext(ctx, getAllFoodLongRange)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Food
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.FoodID,
			&i.FoodName,
			&i.Price,
			&i.FoodType,
			&i.Picture,
			&i.LongRange,
			&i.Description,
			&i.Info,
			&i.Ingredients,
			&i.TimeNeeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFoodTags = `-- name: GetAllFoodTags :many
SELECT DISTINCT tag FROM tags
`

func (q *Queries) GetAllFoodTags(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllFoodTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOrders = `-- name: GetAllOrders :many
SELECT order_id, user_id, order_info, feedback, order_time, estimated_time, is_done, is_ranged, delivery_address, deleted, is_paid FROM orders WHERE deleted = false ORDER BY order_time DESC
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.OrderInfo,
			&i.Feedback,
			&i.OrderTime,
			&i.EstimatedTime,
			&i.IsDone,
			&i.IsRanged,
			&i.DeliveryAddress,
			&i.Deleted,
			&i.IsPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOrdersByUser = `-- name: GetAllOrdersByUser :many
SELECT order_id, user_id, order_info, feedback, order_time, estimated_time, is_done, is_ranged, delivery_address, deleted, is_paid FROM orders WHERE user_id = ? AND deleted = false
`

func (q *Queries) GetAllOrdersByUser(ctx context.Context, userID int32) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrdersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.OrderInfo,
			&i.Feedback,
			&i.OrderTime,
			&i.EstimatedTime,
			&i.IsDone,
			&i.IsRanged,
			&i.DeliveryAddress,
			&i.Deleted,
			&i.IsPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOrdersNotDone = `-- name: GetAllOrdersNotDone :many
SELECT order_id, user_id, order_info, feedback, order_time, estimated_time, is_done, is_ranged, delivery_address, deleted, is_paid FROM orders WHERE is_done = false AND deleted = false ORDER BY order_time DESC
`

func (q *Queries) GetAllOrdersNotDone(ctx context.Context) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrdersNotDone)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.OrderInfo,
			&i.Feedback,
			&i.OrderTime,
			&i.EstimatedTime,
			&i.IsDone,
			&i.IsRanged,
			&i.DeliveryAddress,
			&i.Deleted,
			&i.IsPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAverageRating = `-- name: GetAverageRating :one
SELECT AVG(rating) AS average_rating
FROM items
WHERE food_id = ? AND rating IS NOT NULL
`

func (q *Queries) GetAverageRating(ctx context.Context, foodID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getAverageRating, foodID)
	var average_rating interface{}
	err := row.Scan(&average_rating)
	return average_rating, err
}

const getAverageSpendingByAllUsers = `-- name: GetAverageSpendingByAllUsers :one
SELECT AVG(total_price) AS average_spending
FROM (
    SELECT SUM(food.price * items.quantity) AS total_price
    FROM orders
    JOIN items ON orders.order_id = items.order_id
    JOIN food ON items.food_id = food.food_id
    GROUP BY orders.user_id, orders.order_id
) AS spending
`

func (q *Queries) GetAverageSpendingByAllUsers(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getAverageSpendingByAllUsers)
	var average_spending interface{}
	err := row.Scan(&average_spending)
	return average_spending, err
}

const getAverageSpendingByUser = `-- name: GetAverageSpendingByUser :one
SELECT AVG(total_price) AS average_spending
FROM (
    SELECT SUM(food.price * items.quantity) AS total_price
    FROM orders
    JOIN items ON orders.order_id = items.order_id
    JOIN food ON items.food_id = food.food_id
    WHERE orders.user_id = ?
    GROUP BY orders.order_id
) AS spending
`

func (q *Queries) GetAverageSpendingByUser(ctx context.Context, userID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getAverageSpendingByUser, userID)
	var average_spending interface{}
	err := row.Scan(&average_spending)
	return average_spending, err
}

const getFood = `-- name: GetFood :one
SELECT food_id, food_name, price, food_type, picture, long_range, description, info, ingredients, time_needed FROM food WHERE food_name = ?
`

func (q *Queries) GetFood(ctx context.Context, foodName string) (Food, error) {
	row := q.db.QueryRowContext(ctx, getFood, foodName)
	var i Food
	err := row.Scan(
		&i.FoodID,
		&i.FoodName,
		&i.Price,
		&i.FoodType,
		&i.Picture,
		&i.LongRange,
		&i.Description,
		&i.Info,
		&i.Ingredients,
		&i.TimeNeeded,
	)
	return i, err
}

const getFoodById = `-- name: GetFoodById :one
SELECT food_id, food_name, price, food_type, picture, long_range, description, info, ingredients, time_needed FROM food WHERE food_id = ?
`

func (q *Queries) GetFoodById(ctx context.Context, foodID int32) (Food, error) {
	row := q.db.QueryRowContext(ctx, getFoodById, foodID)
	var i Food
	err := row.Scan(
		&i.FoodID,
		&i.FoodName,
		&i.Price,
		&i.FoodType,
		&i.Picture,
		&i.LongRange,
		&i.Description,
		&i.Info,
		&i.Ingredients,
		&i.TimeNeeded,
	)
	return i, err
}

const getFoodByTag = `-- name: GetFoodByTag :many
SELECT DISTINCT food.food_id, food.food_name, food.price, food.food_type, food.picture, food.long_range, food.description, food.info, food.ingredients, food.time_needed
FROM food
JOIN tags ON food.food_name = tags.food_name
WHERE tags.tag = ?
`

func (q *Queries) GetFoodByTag(ctx context.Context, tag string) ([]Food, error) {
	rows, err := q.db.QueryContext(ctx, getFoodByTag, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Food
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.FoodID,
			&i.FoodName,
			&i.Price,
			&i.FoodType,
			&i.Picture,
			&i.LongRange,
			&i.Description,
			&i.Info,
			&i.Ingredients,
			&i.TimeNeeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoodByType = `-- name: GetFoodByType :many
SELECT food_id, food_name, price, food_type, picture, long_range, description, info, ingredients, time_needed FROM food WHERE food_type = ?
`

func (q *Queries) GetFoodByType(ctx context.Context, foodType string) ([]Food, error) {
	rows, err := q.db.QueryContext(ctx, getFoodByType, foodType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Food
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.FoodID,
			&i.FoodName,
			&i.Price,
			&i.FoodType,
			&i.Picture,
			&i.LongRange,
			&i.Description,
			&i.Info,
			&i.Ingredients,
			&i.TimeNeeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastInsertedOrder = `-- name: GetLastInsertedOrder :one
SELECT order_id, user_id, order_info, feedback, order_time, estimated_time, is_done, is_ranged, delivery_address, deleted, is_paid FROM orders
WHERE order_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastInsertedOrder(ctx context.Context) (Order, error) {
	row := q.db.QueryRowContext(ctx, getLastInsertedOrder)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.OrderInfo,
		&i.Feedback,
		&i.OrderTime,
		&i.EstimatedTime,
		&i.IsDone,
		&i.IsRanged,
		&i.DeliveryAddress,
		&i.Deleted,
		&i.IsPaid,
	)
	return i, err
}

const getLongestTimeNeededFoodInOrder = `-- name: GetLongestTimeNeededFoodInOrder :one
SELECT MAX(food.time_needed) AS longest_time_needed
FROM food
JOIN items ON food.food_id = items.food_id
WHERE items.order_id = ?
`

func (q *Queries) GetLongestTimeNeededFoodInOrder(ctx context.Context, orderID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLongestTimeNeededFoodInOrder, orderID)
	var longest_time_needed interface{}
	err := row.Scan(&longest_time_needed)
	return longest_time_needed, err
}

const getMostOrderedFood = `-- name: GetMostOrderedFood :many
SELECT food.food_name, COUNT(items.food_id) AS order_count
FROM food
JOIN items ON food.food_id = items.food_id
GROUP BY food.food_name
ORDER BY order_count DESC
`

type GetMostOrderedFoodRow struct {
	FoodName   string
	OrderCount int64
}

func (q *Queries) GetMostOrderedFood(ctx context.Context) ([]GetMostOrderedFoodRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostOrderedFood)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostOrderedFoodRow
	for rows.Next() {
		var i GetMostOrderedFoodRow
		if err := rows.Scan(&i.FoodName, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostOrderedTag = `-- name: GetMostOrderedTag :one
SELECT tag, COUNT(*) AS count
FROM tags
JOIN items ON tags.food_name = items.food_id
JOIN orders ON items.order_id = orders.order_id
WHERE orders.deleted = false
GROUP BY tag
ORDER BY count DESC
LIMIT 1
`

type GetMostOrderedTagRow struct {
	Tag   string
	Count int64
}

func (q *Queries) GetMostOrderedTag(ctx context.Context) (GetMostOrderedTagRow, error) {
	row := q.db.QueryRowContext(ctx, getMostOrderedTag)
	var i GetMostOrderedTagRow
	err := row.Scan(&i.Tag, &i.Count)
	return i, err
}

const getOrder = `-- name: GetOrder :many
SELECT order_id, user_id, order_info, feedback, order_time, estimated_time, is_done, is_ranged, delivery_address, deleted, is_paid FROM orders WHERE user_id = ?
`

func (q *Queries) GetOrder(ctx context.Context, userID int32) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrder, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.OrderInfo,
			&i.Feedback,
			&i.OrderTime,
			&i.EstimatedTime,
			&i.IsDone,
			&i.IsRanged,
			&i.DeliveryAddress,
			&i.Deleted,
			&i.IsPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderById = `-- name: GetOrderById :one
SELECT order_id, user_id, order_info, feedback, order_time, estimated_time, is_done, is_ranged, delivery_address, deleted, is_paid FROM orders WHERE order_id = ?
`

func (q *Queries) GetOrderById(ctx context.Context, orderID int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderById, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.OrderInfo,
		&i.Feedback,
		&i.OrderTime,
		&i.EstimatedTime,
		&i.IsDone,
		&i.IsRanged,
		&i.DeliveryAddress,
		&i.Deleted,
		&i.IsPaid,
	)
	return i, err
}

const getOrderTotalPrice = `-- name: GetOrderTotalPrice :one
SELECT SUM(food.price * items.quantity) AS total_price
FROM orders
JOIN items ON orders.order_id = items.order_id
JOIN food ON items.food_id = food.food_id
WHERE orders.order_id = ?
`

func (q *Queries) GetOrderTotalPrice(ctx context.Context, orderID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOrderTotalPrice, orderID)
	var total_price interface{}
	err := row.Scan(&total_price)
	return total_price, err
}

const getOrderedCountByFood = `-- name: GetOrderedCountByFood :one
SELECT COUNT(*) AS ordered_count
FROM items
WHERE food_id = ?
`

func (q *Queries) GetOrderedCountByFood(ctx context.Context, foodID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOrderedCountByFood, foodID)
	var ordered_count int64
	err := row.Scan(&ordered_count)
	return ordered_count, err
}

const getOrderedItems = `-- name: GetOrderedItems :many
SELECT item_id, order_id, food_id, quantity, rating FROM items WHERE order_id = ?
`

func (q *Queries) GetOrderedItems(ctx context.Context, orderID int32) ([]Item, error) {
	rows, err := q.db.QueryContext(ctx, getOrderedItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ItemID,
			&i.OrderID,
			&i.FoodID,
			&i.Quantity,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newTag = `-- name: NewTag :exec
INSERT INTO tags (tag, food_name)
VALUES (
    ?,
    ?
)
`

type NewTagParams struct {
	Tag      string
	FoodName string
}

func (q *Queries) NewTag(ctx context.Context, arg NewTagParams) error {
	_, err := q.db.ExecContext(ctx, newTag, arg.Tag, arg.FoodName)
	return err
}

const rateFood = `-- name: RateFood :exec
UPDATE items
SET
    rating = ?
WHERE
    food_id = ? AND order_id = ?
`

type RateFoodParams struct {
	Rating  sql.NullInt32
	FoodID  int32
	OrderID int32
}

func (q *Queries) RateFood(ctx context.Context, arg RateFoodParams) error {
	_, err := q.db.ExecContext(ctx, rateFood, arg.Rating, arg.FoodID, arg.OrderID)
	return err
}

const rateOrder = `-- name: RateOrder :exec
UPDATE orders
SET
    feedback = ?,
    is_done = true
WHERE
    order_id = ?
`

type RateOrderParams struct {
	Feedback sql.NullString
	OrderID  int32
}

func (q *Queries) RateOrder(ctx context.Context, arg RateOrderParams) error {
	_, err := q.db.ExecContext(ctx, rateOrder, arg.Feedback, arg.OrderID)
	return err
}

const topThreeTagByUser = `-- name: TopThreeTagByUser :many
SELECT tag, COUNT(*) AS count
FROM tags
WHERE food_name IN (
    SELECT food_name
    FROM items
    JOIN orders ON items.order_id = orders.order_id
    WHERE orders.user_id = ?
)
GROUP BY tag
ORDER BY count DESC
LIMIT 3
`

type TopThreeTagByUserRow struct {
	Tag   string
	Count int64
}

func (q *Queries) TopThreeTagByUser(ctx context.Context, userID int32) ([]TopThreeTagByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, topThreeTagByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TopThreeTagByUserRow
	for rows.Next() {
		var i TopThreeTagByUserRow
		if err := rows.Scan(&i.Tag, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEstimatedTime = `-- name: UpdateEstimatedTime :exec
UPDATE orders
SET
    estimated_time = estimated_time + INTERVAL ? MINUTE
WHERE
    order_id = ?
`

type UpdateEstimatedTimeParams struct {
	DATEADD interface{}
	OrderID int32
}

func (q *Queries) UpdateEstimatedTime(ctx context.Context, arg UpdateEstimatedTimeParams) error {
	_, err := q.db.ExecContext(ctx, updateEstimatedTime, arg.DATEADD, arg.OrderID)
	return err
}

const updateFeedback = `-- name: UpdateFeedback :exec
UPDATE orders
SET
    feedback = ?
WHERE
    order_id = ?
`

type UpdateFeedbackParams struct {
	Feedback sql.NullString
	OrderID  int32
}

func (q *Queries) UpdateFeedback(ctx context.Context, arg UpdateFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, updateFeedback, arg.Feedback, arg.OrderID)
	return err
}

const updateOrderDoneStatus = `-- name: UpdateOrderDoneStatus :exec
UPDATE orders
SET
    is_done = true
WHERE
    order_id = ?
`

func (q *Queries) UpdateOrderDoneStatus(ctx context.Context, orderID int32) error {
	_, err := q.db.ExecContext(ctx, updateOrderDoneStatus, orderID)
	return err
}

const updateOrderPayment = `-- name: UpdateOrderPayment :exec
UPDATE orders
SET
    is_paid = true
WHERE
    order_id = ?
`

func (q *Queries) UpdateOrderPayment(ctx context.Context, orderID int32) error {
	_, err := q.db.ExecContext(ctx, updateOrderPayment, orderID)
	return err
}

const updateOrderUser = `-- name: UpdateOrderUser :exec
UPDATE accounts
SET
    balance = ?
WHERE
    id = ?
`

type UpdateOrderUserParams struct {
	Balance float64
	ID      int32
}

func (q *Queries) UpdateOrderUser(ctx context.Context, arg UpdateOrderUserParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderUser, arg.Balance, arg.ID)
	return err
}

const updateUserTagByID = `-- name: UpdateUserTagByID :exec
UPDATE accounts
SET
    user_tag = ?
WHERE
    id = ?
`

type UpdateUserTagByIDParams struct {
	UserTag sql.NullString
	ID      int32
}

func (q *Queries) UpdateUserTagByID(ctx context.Context, arg UpdateUserTagByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateUserTagByID, arg.UserTag, arg.ID)
	return err
}
